#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TLlamaServiceVersion:
  V1 = 0

  _VALUES_TO_NAMES = {
    0: "V1",
  }

  _NAMES_TO_VALUES = {
    "V1": 0,
  }

class TStatusCode:
  OK = 0
  REQUEST_ERROR = 1
  INTERNAL_ERROR = 2

  _VALUES_TO_NAMES = {
    0: "OK",
    1: "REQUEST_ERROR",
    2: "INTERNAL_ERROR",
  }

  _NAMES_TO_VALUES = {
    "OK": 0,
    "REQUEST_ERROR": 1,
    "INTERNAL_ERROR": 2,
  }

class TLocationEnforcement:
  MUST = 0
  PREFERRED = 1
  DONT_CARE = 2

  _VALUES_TO_NAMES = {
    0: "MUST",
    1: "PREFERRED",
    2: "DONT_CARE",
  }

  _NAMES_TO_VALUES = {
    "MUST": 0,
    "PREFERRED": 1,
    "DONT_CARE": 2,
  }


class TUniqueId:
  """
  Attributes:
   - hi
   - lo
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'hi', None, None, ), # 1
    (2, TType.I64, 'lo', None, None, ), # 2
  )

  def __init__(self, hi=None, lo=None,):
    self.hi = hi
    self.lo = lo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.hi = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.lo = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUniqueId')
    if self.hi is not None:
      oprot.writeFieldBegin('hi', TType.I64, 1)
      oprot.writeI64(self.hi)
      oprot.writeFieldEnd()
    if self.lo is not None:
      oprot.writeFieldBegin('lo', TType.I64, 2)
      oprot.writeI64(self.lo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hi is None:
      raise TProtocol.TProtocolException(message='Required field hi is unset!')
    if self.lo is None:
      raise TProtocol.TProtocolException(message='Required field lo is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hi)
    value = (value * 31) ^ hash(self.lo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TNetworkAddress:
  """
  Attributes:
   - hostname
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hostname', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, hostname=None, port=None,):
    self.hostname = hostname
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hostname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TNetworkAddress')
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 1)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    if self.port is None:
      raise TProtocol.TProtocolException(message='Required field port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TStatus:
  """
  Attributes:
   - status_code
   - error_code
   - error_msgs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status_code', None, None, ), # 1
    (2, TType.I16, 'error_code', None, None, ), # 2
    (3, TType.LIST, 'error_msgs', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, status_code=None, error_code=None, error_msgs=None,):
    self.status_code = status_code
    self.error_code = error_code
    self.error_msgs = error_msgs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.error_code = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.error_msgs = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.error_msgs.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TStatus')
    if self.status_code is not None:
      oprot.writeFieldBegin('status_code', TType.I32, 1)
      oprot.writeI32(self.status_code)
      oprot.writeFieldEnd()
    if self.error_code is not None:
      oprot.writeFieldBegin('error_code', TType.I16, 2)
      oprot.writeI16(self.error_code)
      oprot.writeFieldEnd()
    if self.error_msgs is not None:
      oprot.writeFieldBegin('error_msgs', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.error_msgs))
      for iter6 in self.error_msgs:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status_code is None:
      raise TProtocol.TProtocolException(message='Required field status_code is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status_code)
    value = (value * 31) ^ hash(self.error_code)
    value = (value * 31) ^ hash(self.error_msgs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResource:
  """
  Attributes:
   - client_resource_id
   - v_cpu_cores
   - memory_mb
   - askedLocation
   - enforcement
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'client_resource_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 1
    (2, TType.I16, 'v_cpu_cores', None, None, ), # 2
    (3, TType.I32, 'memory_mb', None, None, ), # 3
    (4, TType.STRING, 'askedLocation', None, None, ), # 4
    (5, TType.I32, 'enforcement', None, None, ), # 5
  )

  def __init__(self, client_resource_id=None, v_cpu_cores=None, memory_mb=None, askedLocation=None, enforcement=None,):
    self.client_resource_id = client_resource_id
    self.v_cpu_cores = v_cpu_cores
    self.memory_mb = memory_mb
    self.askedLocation = askedLocation
    self.enforcement = enforcement

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.client_resource_id = TUniqueId()
          self.client_resource_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.v_cpu_cores = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.memory_mb = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.askedLocation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.enforcement = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResource')
    if self.client_resource_id is not None:
      oprot.writeFieldBegin('client_resource_id', TType.STRUCT, 1)
      self.client_resource_id.write(oprot)
      oprot.writeFieldEnd()
    if self.v_cpu_cores is not None:
      oprot.writeFieldBegin('v_cpu_cores', TType.I16, 2)
      oprot.writeI16(self.v_cpu_cores)
      oprot.writeFieldEnd()
    if self.memory_mb is not None:
      oprot.writeFieldBegin('memory_mb', TType.I32, 3)
      oprot.writeI32(self.memory_mb)
      oprot.writeFieldEnd()
    if self.askedLocation is not None:
      oprot.writeFieldBegin('askedLocation', TType.STRING, 4)
      oprot.writeString(self.askedLocation)
      oprot.writeFieldEnd()
    if self.enforcement is not None:
      oprot.writeFieldBegin('enforcement', TType.I32, 5)
      oprot.writeI32(self.enforcement)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.client_resource_id is None:
      raise TProtocol.TProtocolException(message='Required field client_resource_id is unset!')
    if self.v_cpu_cores is None:
      raise TProtocol.TProtocolException(message='Required field v_cpu_cores is unset!')
    if self.memory_mb is None:
      raise TProtocol.TProtocolException(message='Required field memory_mb is unset!')
    if self.askedLocation is None:
      raise TProtocol.TProtocolException(message='Required field askedLocation is unset!')
    if self.enforcement is None:
      raise TProtocol.TProtocolException(message='Required field enforcement is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.client_resource_id)
    value = (value * 31) ^ hash(self.v_cpu_cores)
    value = (value * 31) ^ hash(self.memory_mb)
    value = (value * 31) ^ hash(self.askedLocation)
    value = (value * 31) ^ hash(self.enforcement)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAllocatedResource:
  """
  Attributes:
   - reservation_id
   - client_resource_id
   - rm_resource_id
   - v_cpu_cores
   - memory_mb
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'reservation_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'client_resource_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRING, 'rm_resource_id', None, None, ), # 3
    (4, TType.I16, 'v_cpu_cores', None, None, ), # 4
    (5, TType.I32, 'memory_mb', None, None, ), # 5
    (6, TType.STRING, 'location', None, None, ), # 6
  )

  def __init__(self, reservation_id=None, client_resource_id=None, rm_resource_id=None, v_cpu_cores=None, memory_mb=None, location=None,):
    self.reservation_id = reservation_id
    self.client_resource_id = client_resource_id
    self.rm_resource_id = rm_resource_id
    self.v_cpu_cores = v_cpu_cores
    self.memory_mb = memory_mb
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.reservation_id = TUniqueId()
          self.reservation_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.client_resource_id = TUniqueId()
          self.client_resource_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.rm_resource_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.v_cpu_cores = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.memory_mb = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAllocatedResource')
    if self.reservation_id is not None:
      oprot.writeFieldBegin('reservation_id', TType.STRUCT, 1)
      self.reservation_id.write(oprot)
      oprot.writeFieldEnd()
    if self.client_resource_id is not None:
      oprot.writeFieldBegin('client_resource_id', TType.STRUCT, 2)
      self.client_resource_id.write(oprot)
      oprot.writeFieldEnd()
    if self.rm_resource_id is not None:
      oprot.writeFieldBegin('rm_resource_id', TType.STRING, 3)
      oprot.writeString(self.rm_resource_id)
      oprot.writeFieldEnd()
    if self.v_cpu_cores is not None:
      oprot.writeFieldBegin('v_cpu_cores', TType.I16, 4)
      oprot.writeI16(self.v_cpu_cores)
      oprot.writeFieldEnd()
    if self.memory_mb is not None:
      oprot.writeFieldBegin('memory_mb', TType.I32, 5)
      oprot.writeI32(self.memory_mb)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 6)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.reservation_id is None:
      raise TProtocol.TProtocolException(message='Required field reservation_id is unset!')
    if self.client_resource_id is None:
      raise TProtocol.TProtocolException(message='Required field client_resource_id is unset!')
    if self.rm_resource_id is None:
      raise TProtocol.TProtocolException(message='Required field rm_resource_id is unset!')
    if self.v_cpu_cores is None:
      raise TProtocol.TProtocolException(message='Required field v_cpu_cores is unset!')
    if self.memory_mb is None:
      raise TProtocol.TProtocolException(message='Required field memory_mb is unset!')
    if self.location is None:
      raise TProtocol.TProtocolException(message='Required field location is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.reservation_id)
    value = (value * 31) ^ hash(self.client_resource_id)
    value = (value * 31) ^ hash(self.rm_resource_id)
    value = (value * 31) ^ hash(self.v_cpu_cores)
    value = (value * 31) ^ hash(self.memory_mb)
    value = (value * 31) ^ hash(self.location)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TNodeCapacity:
  """
  Attributes:
   - total_v_cpu_cores
   - total_memory_mb
   - free_v_cpu_cores
   - free_memory_mb
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'total_v_cpu_cores', None, None, ), # 1
    (2, TType.I32, 'total_memory_mb', None, None, ), # 2
    (3, TType.I16, 'free_v_cpu_cores', None, None, ), # 3
    (4, TType.I32, 'free_memory_mb', None, None, ), # 4
  )

  def __init__(self, total_v_cpu_cores=None, total_memory_mb=None, free_v_cpu_cores=None, free_memory_mb=None,):
    self.total_v_cpu_cores = total_v_cpu_cores
    self.total_memory_mb = total_memory_mb
    self.free_v_cpu_cores = free_v_cpu_cores
    self.free_memory_mb = free_memory_mb

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.total_v_cpu_cores = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.total_memory_mb = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.free_v_cpu_cores = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.free_memory_mb = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TNodeCapacity')
    if self.total_v_cpu_cores is not None:
      oprot.writeFieldBegin('total_v_cpu_cores', TType.I16, 1)
      oprot.writeI16(self.total_v_cpu_cores)
      oprot.writeFieldEnd()
    if self.total_memory_mb is not None:
      oprot.writeFieldBegin('total_memory_mb', TType.I32, 2)
      oprot.writeI32(self.total_memory_mb)
      oprot.writeFieldEnd()
    if self.free_v_cpu_cores is not None:
      oprot.writeFieldBegin('free_v_cpu_cores', TType.I16, 3)
      oprot.writeI16(self.free_v_cpu_cores)
      oprot.writeFieldEnd()
    if self.free_memory_mb is not None:
      oprot.writeFieldBegin('free_memory_mb', TType.I32, 4)
      oprot.writeI32(self.free_memory_mb)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.total_v_cpu_cores is None:
      raise TProtocol.TProtocolException(message='Required field total_v_cpu_cores is unset!')
    if self.total_memory_mb is None:
      raise TProtocol.TProtocolException(message='Required field total_memory_mb is unset!')
    if self.free_v_cpu_cores is None:
      raise TProtocol.TProtocolException(message='Required field free_v_cpu_cores is unset!')
    if self.free_memory_mb is None:
      raise TProtocol.TProtocolException(message='Required field free_memory_mb is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.total_v_cpu_cores)
    value = (value * 31) ^ hash(self.total_memory_mb)
    value = (value * 31) ^ hash(self.free_v_cpu_cores)
    value = (value * 31) ^ hash(self.free_memory_mb)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMRegisterRequest:
  """
  Attributes:
   - version
   - client_id
   - notification_callback_service
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'client_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notification_callback_service', (TNetworkAddress, TNetworkAddress.thrift_spec), None, ), # 3
  )

  def __init__(self, version=None, client_id=None, notification_callback_service=None,):
    self.version = version
    self.client_id = client_id
    self.notification_callback_service = notification_callback_service

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.client_id = TUniqueId()
          self.client_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notification_callback_service = TNetworkAddress()
          self.notification_callback_service.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMRegisterRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.client_id is not None:
      oprot.writeFieldBegin('client_id', TType.STRUCT, 2)
      self.client_id.write(oprot)
      oprot.writeFieldEnd()
    if self.notification_callback_service is not None:
      oprot.writeFieldBegin('notification_callback_service', TType.STRUCT, 3)
      self.notification_callback_service.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.client_id is None:
      raise TProtocol.TProtocolException(message='Required field client_id is unset!')
    if self.notification_callback_service is None:
      raise TProtocol.TProtocolException(message='Required field notification_callback_service is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.client_id)
    value = (value * 31) ^ hash(self.notification_callback_service)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMRegisterResponse:
  """
  Attributes:
   - status
   - am_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, am_handle=None,):
    self.status = status
    self.am_handle = am_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMRegisterResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.am_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMUnregisterRequest:
  """
  Attributes:
   - version
   - am_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, version=None, am_handle=None,):
    self.version = version
    self.am_handle = am_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMUnregisterRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.am_handle is None:
      raise TProtocol.TProtocolException(message='Required field am_handle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.am_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMUnregisterResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMUnregisterResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMReservationRequest:
  """
  Attributes:
   - version
   - am_handle
   - user
   - queue
   - resources
   - gang
   - reservation_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'queue', None, None, ), # 4
    (5, TType.LIST, 'resources', (TType.STRUCT,(TResource, TResource.thrift_spec)), None, ), # 5
    (6, TType.BOOL, 'gang', None, None, ), # 6
    (7, TType.STRUCT, 'reservation_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 7
  )

  def __init__(self, version=None, am_handle=None, user=None, queue=None, resources=None, gang=None, reservation_id=None,):
    self.version = version
    self.am_handle = am_handle
    self.user = user
    self.queue = queue
    self.resources = resources
    self.gang = gang
    self.reservation_id = reservation_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.queue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.resources = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = TResource()
            _elem12.read(iprot)
            self.resources.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.gang = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.reservation_id = TUniqueId()
          self.reservation_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMReservationRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.queue is not None:
      oprot.writeFieldBegin('queue', TType.STRING, 4)
      oprot.writeString(self.queue)
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.resources))
      for iter13 in self.resources:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.gang is not None:
      oprot.writeFieldBegin('gang', TType.BOOL, 6)
      oprot.writeBool(self.gang)
      oprot.writeFieldEnd()
    if self.reservation_id is not None:
      oprot.writeFieldBegin('reservation_id', TType.STRUCT, 7)
      self.reservation_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.am_handle is None:
      raise TProtocol.TProtocolException(message='Required field am_handle is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.resources is None:
      raise TProtocol.TProtocolException(message='Required field resources is unset!')
    if self.gang is None:
      raise TProtocol.TProtocolException(message='Required field gang is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.am_handle)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.queue)
    value = (value * 31) ^ hash(self.resources)
    value = (value * 31) ^ hash(self.gang)
    value = (value * 31) ^ hash(self.reservation_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMReservationResponse:
  """
  Attributes:
   - status
   - reservation_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'reservation_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, reservation_id=None,):
    self.status = status
    self.reservation_id = reservation_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.reservation_id = TUniqueId()
          self.reservation_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMReservationResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.reservation_id is not None:
      oprot.writeFieldBegin('reservation_id', TType.STRUCT, 2)
      self.reservation_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.reservation_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMReservationExpansionRequest:
  """
  Attributes:
   - version
   - am_handle
   - expansion_of
   - resource
   - expansion_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'expansion_of', (TUniqueId, TUniqueId.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'resource', (TResource, TResource.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'expansion_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 5
  )

  def __init__(self, version=None, am_handle=None, expansion_of=None, resource=None, expansion_id=None,):
    self.version = version
    self.am_handle = am_handle
    self.expansion_of = expansion_of
    self.resource = resource
    self.expansion_id = expansion_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.expansion_of = TUniqueId()
          self.expansion_of.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.resource = TResource()
          self.resource.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.expansion_id = TUniqueId()
          self.expansion_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMReservationExpansionRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    if self.expansion_of is not None:
      oprot.writeFieldBegin('expansion_of', TType.STRUCT, 3)
      self.expansion_of.write(oprot)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRUCT, 4)
      self.resource.write(oprot)
      oprot.writeFieldEnd()
    if self.expansion_id is not None:
      oprot.writeFieldBegin('expansion_id', TType.STRUCT, 5)
      self.expansion_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.am_handle is None:
      raise TProtocol.TProtocolException(message='Required field am_handle is unset!')
    if self.expansion_of is None:
      raise TProtocol.TProtocolException(message='Required field expansion_of is unset!')
    if self.resource is None:
      raise TProtocol.TProtocolException(message='Required field resource is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.am_handle)
    value = (value * 31) ^ hash(self.expansion_of)
    value = (value * 31) ^ hash(self.resource)
    value = (value * 31) ^ hash(self.expansion_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMReservationExpansionResponse:
  """
  Attributes:
   - status
   - reservation_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'reservation_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, reservation_id=None,):
    self.status = status
    self.reservation_id = reservation_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.reservation_id = TUniqueId()
          self.reservation_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMReservationExpansionResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.reservation_id is not None:
      oprot.writeFieldBegin('reservation_id', TType.STRUCT, 2)
      self.reservation_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.reservation_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMReleaseRequest:
  """
  Attributes:
   - version
   - am_handle
   - reservation_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'reservation_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 3
  )

  def __init__(self, version=None, am_handle=None, reservation_id=None,):
    self.version = version
    self.am_handle = am_handle
    self.reservation_id = reservation_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.reservation_id = TUniqueId()
          self.reservation_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMReleaseRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    if self.reservation_id is not None:
      oprot.writeFieldBegin('reservation_id', TType.STRUCT, 3)
      self.reservation_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.am_handle is None:
      raise TProtocol.TProtocolException(message='Required field am_handle is unset!')
    if self.reservation_id is None:
      raise TProtocol.TProtocolException(message='Required field reservation_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.am_handle)
    value = (value * 31) ^ hash(self.reservation_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMReleaseResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMReleaseResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMGetNodesRequest:
  """
  Attributes:
   - version
   - am_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, version=None, am_handle=None,):
    self.version = version
    self.am_handle = am_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMGetNodesRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.am_handle is None:
      raise TProtocol.TProtocolException(message='Required field am_handle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.am_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMGetNodesResponse:
  """
  Attributes:
   - status
   - nodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.LIST, 'nodes', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, status=None, nodes=None,):
    self.status = status
    self.nodes = nodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.nodes.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMGetNodesResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.nodes is not None:
      oprot.writeFieldBegin('nodes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.nodes))
      for iter20 in self.nodes:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.nodes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMAdminReleaseRequest:
  """
  Attributes:
   - version
   - do_not_cache
   - queues
   - handles
   - reservations
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.BOOL, 'do_not_cache', None, False, ), # 2
    (3, TType.LIST, 'queues', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'handles', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'reservations', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 5
  )

  def __init__(self, version=None, do_not_cache=thrift_spec[2][4], queues=None, handles=None, reservations=None,):
    self.version = version
    self.do_not_cache = do_not_cache
    self.queues = queues
    self.handles = handles
    self.reservations = reservations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.do_not_cache = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.queues = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString();
            self.queues.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.handles = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = TUniqueId()
            _elem32.read(iprot)
            self.handles.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.reservations = []
          (_etype36, _size33) = iprot.readListBegin()
          for _i37 in xrange(_size33):
            _elem38 = TUniqueId()
            _elem38.read(iprot)
            self.reservations.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMAdminReleaseRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.do_not_cache is not None:
      oprot.writeFieldBegin('do_not_cache', TType.BOOL, 2)
      oprot.writeBool(self.do_not_cache)
      oprot.writeFieldEnd()
    if self.queues is not None:
      oprot.writeFieldBegin('queues', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.queues))
      for iter39 in self.queues:
        oprot.writeString(iter39)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.handles is not None:
      oprot.writeFieldBegin('handles', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.handles))
      for iter40 in self.handles:
        iter40.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.reservations is not None:
      oprot.writeFieldBegin('reservations', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.reservations))
      for iter41 in self.reservations:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.do_not_cache)
    value = (value * 31) ^ hash(self.queues)
    value = (value * 31) ^ hash(self.handles)
    value = (value * 31) ^ hash(self.reservations)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMAdminReleaseResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMAdminReleaseResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMAdminEmptyCacheRequest:
  """
  Attributes:
   - version
   - allQueues
   - queues
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.BOOL, 'allQueues', None, False, ), # 2
    (3, TType.LIST, 'queues', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, version=None, allQueues=thrift_spec[2][4], queues=None,):
    self.version = version
    self.allQueues = allQueues
    self.queues = queues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.allQueues = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.queues = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.queues.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMAdminEmptyCacheRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.allQueues is not None:
      oprot.writeFieldBegin('allQueues', TType.BOOL, 2)
      oprot.writeBool(self.allQueues)
      oprot.writeFieldEnd()
    if self.queues is not None:
      oprot.writeFieldBegin('queues', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.queues))
      for iter48 in self.queues:
        oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.allQueues)
    value = (value * 31) ^ hash(self.queues)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMAdminEmptyCacheResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMAdminEmptyCacheResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaNMRegisterRequest:
  """
  Attributes:
   - version
   - client_id
   - notification_callback_service
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'client_id', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notification_callback_service', (TNetworkAddress, TNetworkAddress.thrift_spec), None, ), # 3
  )

  def __init__(self, version=None, client_id=None, notification_callback_service=None,):
    self.version = version
    self.client_id = client_id
    self.notification_callback_service = notification_callback_service

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.client_id = TUniqueId()
          self.client_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notification_callback_service = TNetworkAddress()
          self.notification_callback_service.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaNMRegisterRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.client_id is not None:
      oprot.writeFieldBegin('client_id', TType.STRUCT, 2)
      self.client_id.write(oprot)
      oprot.writeFieldEnd()
    if self.notification_callback_service is not None:
      oprot.writeFieldBegin('notification_callback_service', TType.STRUCT, 3)
      self.notification_callback_service.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.client_id is None:
      raise TProtocol.TProtocolException(message='Required field client_id is unset!')
    if self.notification_callback_service is None:
      raise TProtocol.TProtocolException(message='Required field notification_callback_service is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.client_id)
    value = (value * 31) ^ hash(self.notification_callback_service)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaNMRegisterResponse:
  """
  Attributes:
   - status
   - nm_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nm_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, nm_handle=None,):
    self.status = status
    self.nm_handle = nm_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nm_handle = TUniqueId()
          self.nm_handle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaNMRegisterResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.nm_handle is not None:
      oprot.writeFieldBegin('nm_handle', TType.STRUCT, 2)
      self.nm_handle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.nm_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaNMUnregisterRequest:
  """
  Attributes:
   - version
   - nm_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'nm_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, version=None, nm_handle=None,):
    self.version = version
    self.nm_handle = nm_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nm_handle = TUniqueId()
          self.nm_handle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaNMUnregisterRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.nm_handle is not None:
      oprot.writeFieldBegin('nm_handle', TType.STRUCT, 2)
      self.nm_handle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.nm_handle is None:
      raise TProtocol.TProtocolException(message='Required field nm_handle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.nm_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaNMUnregisterResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaNMUnregisterResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMNotificationRequest:
  """
  Attributes:
   - version
   - am_handle
   - heartbeat
   - allocated_reservation_ids
   - allocated_resources
   - rejected_reservation_ids
   - rejected_client_resource_ids
   - lost_client_resource_ids
   - preempted_reservation_ids
   - preempted_client_resource_ids
   - admin_released_reservation_ids
   - lost_reservation_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'am_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'heartbeat', None, None, ), # 3
    (4, TType.LIST, 'allocated_reservation_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'allocated_resources', (TType.STRUCT,(TAllocatedResource, TAllocatedResource.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'rejected_reservation_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'rejected_client_resource_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'lost_client_resource_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'preempted_reservation_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 9
    (10, TType.LIST, 'preempted_client_resource_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 10
    (11, TType.LIST, 'admin_released_reservation_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 11
    (12, TType.LIST, 'lost_reservation_ids', (TType.STRUCT,(TUniqueId, TUniqueId.thrift_spec)), None, ), # 12
  )

  def __init__(self, version=None, am_handle=None, heartbeat=None, allocated_reservation_ids=None, allocated_resources=None, rejected_reservation_ids=None, rejected_client_resource_ids=None, lost_client_resource_ids=None, preempted_reservation_ids=None, preempted_client_resource_ids=None, admin_released_reservation_ids=None, lost_reservation_ids=None,):
    self.version = version
    self.am_handle = am_handle
    self.heartbeat = heartbeat
    self.allocated_reservation_ids = allocated_reservation_ids
    self.allocated_resources = allocated_resources
    self.rejected_reservation_ids = rejected_reservation_ids
    self.rejected_client_resource_ids = rejected_client_resource_ids
    self.lost_client_resource_ids = lost_client_resource_ids
    self.preempted_reservation_ids = preempted_reservation_ids
    self.preempted_client_resource_ids = preempted_client_resource_ids
    self.admin_released_reservation_ids = admin_released_reservation_ids
    self.lost_reservation_ids = lost_reservation_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.am_handle = TUniqueId()
          self.am_handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.heartbeat = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.allocated_reservation_ids = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = TUniqueId()
            _elem54.read(iprot)
            self.allocated_reservation_ids.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.allocated_resources = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = TAllocatedResource()
            _elem60.read(iprot)
            self.allocated_resources.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.rejected_reservation_ids = []
          (_etype64, _size61) = iprot.readListBegin()
          for _i65 in xrange(_size61):
            _elem66 = TUniqueId()
            _elem66.read(iprot)
            self.rejected_reservation_ids.append(_elem66)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.rejected_client_resource_ids = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = TUniqueId()
            _elem72.read(iprot)
            self.rejected_client_resource_ids.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.lost_client_resource_ids = []
          (_etype76, _size73) = iprot.readListBegin()
          for _i77 in xrange(_size73):
            _elem78 = TUniqueId()
            _elem78.read(iprot)
            self.lost_client_resource_ids.append(_elem78)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.preempted_reservation_ids = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = TUniqueId()
            _elem84.read(iprot)
            self.preempted_reservation_ids.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.preempted_client_resource_ids = []
          (_etype88, _size85) = iprot.readListBegin()
          for _i89 in xrange(_size85):
            _elem90 = TUniqueId()
            _elem90.read(iprot)
            self.preempted_client_resource_ids.append(_elem90)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.admin_released_reservation_ids = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = TUniqueId()
            _elem96.read(iprot)
            self.admin_released_reservation_ids.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.lost_reservation_ids = []
          (_etype100, _size97) = iprot.readListBegin()
          for _i101 in xrange(_size97):
            _elem102 = TUniqueId()
            _elem102.read(iprot)
            self.lost_reservation_ids.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMNotificationRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.am_handle is not None:
      oprot.writeFieldBegin('am_handle', TType.STRUCT, 2)
      self.am_handle.write(oprot)
      oprot.writeFieldEnd()
    if self.heartbeat is not None:
      oprot.writeFieldBegin('heartbeat', TType.BOOL, 3)
      oprot.writeBool(self.heartbeat)
      oprot.writeFieldEnd()
    if self.allocated_reservation_ids is not None:
      oprot.writeFieldBegin('allocated_reservation_ids', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.allocated_reservation_ids))
      for iter103 in self.allocated_reservation_ids:
        iter103.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.allocated_resources is not None:
      oprot.writeFieldBegin('allocated_resources', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.allocated_resources))
      for iter104 in self.allocated_resources:
        iter104.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rejected_reservation_ids is not None:
      oprot.writeFieldBegin('rejected_reservation_ids', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.rejected_reservation_ids))
      for iter105 in self.rejected_reservation_ids:
        iter105.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rejected_client_resource_ids is not None:
      oprot.writeFieldBegin('rejected_client_resource_ids', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.rejected_client_resource_ids))
      for iter106 in self.rejected_client_resource_ids:
        iter106.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.lost_client_resource_ids is not None:
      oprot.writeFieldBegin('lost_client_resource_ids', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.lost_client_resource_ids))
      for iter107 in self.lost_client_resource_ids:
        iter107.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.preempted_reservation_ids is not None:
      oprot.writeFieldBegin('preempted_reservation_ids', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.preempted_reservation_ids))
      for iter108 in self.preempted_reservation_ids:
        iter108.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.preempted_client_resource_ids is not None:
      oprot.writeFieldBegin('preempted_client_resource_ids', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.preempted_client_resource_ids))
      for iter109 in self.preempted_client_resource_ids:
        iter109.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.admin_released_reservation_ids is not None:
      oprot.writeFieldBegin('admin_released_reservation_ids', TType.LIST, 11)
      oprot.writeListBegin(TType.STRUCT, len(self.admin_released_reservation_ids))
      for iter110 in self.admin_released_reservation_ids:
        iter110.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.lost_reservation_ids is not None:
      oprot.writeFieldBegin('lost_reservation_ids', TType.LIST, 12)
      oprot.writeListBegin(TType.STRUCT, len(self.lost_reservation_ids))
      for iter111 in self.lost_reservation_ids:
        iter111.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.am_handle is None:
      raise TProtocol.TProtocolException(message='Required field am_handle is unset!')
    if self.heartbeat is None:
      raise TProtocol.TProtocolException(message='Required field heartbeat is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.am_handle)
    value = (value * 31) ^ hash(self.heartbeat)
    value = (value * 31) ^ hash(self.allocated_reservation_ids)
    value = (value * 31) ^ hash(self.allocated_resources)
    value = (value * 31) ^ hash(self.rejected_reservation_ids)
    value = (value * 31) ^ hash(self.rejected_client_resource_ids)
    value = (value * 31) ^ hash(self.lost_client_resource_ids)
    value = (value * 31) ^ hash(self.preempted_reservation_ids)
    value = (value * 31) ^ hash(self.preempted_client_resource_ids)
    value = (value * 31) ^ hash(self.admin_released_reservation_ids)
    value = (value * 31) ^ hash(self.lost_reservation_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaAMNotificationResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaAMNotificationResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaNMNotificationRequest:
  """
  Attributes:
   - version
   - nm_handle
   - node_capacity
   - preempted_rm_resource_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'nm_handle', (TUniqueId, TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'node_capacity', (TNodeCapacity, TNodeCapacity.thrift_spec), None, ), # 3
    (4, TType.LIST, 'preempted_rm_resource_ids', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, version=None, nm_handle=None, node_capacity=None, preempted_rm_resource_ids=None,):
    self.version = version
    self.nm_handle = nm_handle
    self.node_capacity = node_capacity
    self.preempted_rm_resource_ids = preempted_rm_resource_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nm_handle = TUniqueId()
          self.nm_handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.node_capacity = TNodeCapacity()
          self.node_capacity.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.preempted_rm_resource_ids = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = iprot.readString();
            self.preempted_rm_resource_ids.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaNMNotificationRequest')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.nm_handle is not None:
      oprot.writeFieldBegin('nm_handle', TType.STRUCT, 2)
      self.nm_handle.write(oprot)
      oprot.writeFieldEnd()
    if self.node_capacity is not None:
      oprot.writeFieldBegin('node_capacity', TType.STRUCT, 3)
      self.node_capacity.write(oprot)
      oprot.writeFieldEnd()
    if self.preempted_rm_resource_ids is not None:
      oprot.writeFieldBegin('preempted_rm_resource_ids', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.preempted_rm_resource_ids))
      for iter118 in self.preempted_rm_resource_ids:
        oprot.writeString(iter118)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    if self.nm_handle is None:
      raise TProtocol.TProtocolException(message='Required field nm_handle is unset!')
    if self.node_capacity is None:
      raise TProtocol.TProtocolException(message='Required field node_capacity is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.nm_handle)
    value = (value * 31) ^ hash(self.node_capacity)
    value = (value * 31) ^ hash(self.preempted_rm_resource_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLlamaNMNotificationResponse:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLlamaNMNotificationResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
