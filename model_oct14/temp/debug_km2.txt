starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.1 MiB      0.2 MiB           for i in range(nodes):
    59    235.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.1 MiB      0.0 MiB               for j in range(nodes):
    63    235.1 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.1 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.1 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.1 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.1 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.1 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 6 time 1566423360.284836
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.9 MiB    233.9 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.9 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.9 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.9 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.9 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.9 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.9 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.9 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.9 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.4 MiB      0.2 MiB           for i in range(nodes):
    59    235.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.4 MiB      0.0 MiB               for j in range(nodes):
    63    235.4 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.4 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.4 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.9 MiB      0.1 MiB           for i in range(nodes):
    59    237.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.9 MiB      0.0 MiB               for j in range(nodes):
    63    237.9 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.9 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.9 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 32 time 1566423360.28852
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.5 MiB    236.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.1 MiB      0.0 MiB           for i in range(nodes):
    59    238.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.1 MiB      0.0 MiB               for j in range(nodes):
    63    238.1 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.1 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.1 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.5 MiB    231.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.9 MiB      0.2 MiB           for i in range(nodes):
    59    237.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.9 MiB      0.0 MiB               for j in range(nodes):
    63    237.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.9 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.9 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.9 MiB      2.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 18 time 1566423360.3156452
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.6 MiB    236.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.2 MiB      0.1 MiB           for i in range(nodes):
    59    238.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.2 MiB      0.0 MiB               for j in range(nodes):
    63    238.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.2 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.6 MiB    229.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.9 MiB      0.1 MiB           for i in range(nodes):
    59    235.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.9 MiB      0.1 MiB               for j in range(nodes):
    63    235.9 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.9 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.9 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.9 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 38 time 1566423360.6117866
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    234.5 MiB    234.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    234.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    234.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    234.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    234.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    234.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    234.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    234.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    234.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.1 MiB      0.0 MiB           for i in range(nodes):
    59    236.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.1 MiB      0.0 MiB               for j in range(nodes):
    63    236.1 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.1 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.1 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.3 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.3 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.3 MiB      0.2 MiB           for i in range(nodes):
    59    239.3 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.3 MiB      0.1 MiB               for j in range(nodes):
    63    239.3 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.3 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.3 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.3 MiB      2.3 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.3 MiB      0.1 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.3 MiB      0.3 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.3 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.4 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 10 time 1566423360.819693
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.0 MiB    238.0 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.0 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.0 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.0 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.0 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.0 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.0 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.0 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.0 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.6 MiB      0.2 MiB           for i in range(nodes):
    59    239.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.6 MiB      0.0 MiB               for j in range(nodes):
    63    239.6 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.6 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.6 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.6 MiB    229.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    234.4 MiB      0.1 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    234.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    234.4 MiB      0.1 MiB           for i in range(nodes):
    59    234.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    234.4 MiB      0.1 MiB               for j in range(nodes):
    63    234.4 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    234.4 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    234.4 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    234.4 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    234.4 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    234.4 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    234.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.4 MiB      2.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 22 time 1566423360.9073093
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.0 MiB    235.0 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.0 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.0 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.0 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.0 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.0 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.0 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.0 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.0 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.6 MiB      0.2 MiB           for i in range(nodes):
    59    236.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.6 MiB      0.0 MiB               for j in range(nodes):
    63    236.6 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.6 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.6 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.4 MiB      0.1 MiB           for i in range(nodes):
    59    236.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.4 MiB      0.0 MiB               for j in range(nodes):
    63    236.4 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.4 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.4 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    236.4 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.4 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.4 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.6 MiB      0.2 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 19 time 1566423361.0061584
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    237.2 MiB    237.2 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    237.2 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    237.2 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    237.2 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    237.2 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    237.2 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    237.2 MiB      0.0 MiB           for i in range(max_delay+2):
    50    237.2 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    237.2 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.7 MiB      0.0 MiB           for i in range(nodes):
    59    240.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.7 MiB      0.0 MiB               for j in range(nodes):
    63    240.7 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.7 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.7 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.1 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    234.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    234.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    234.6 MiB      0.2 MiB           for i in range(nodes):
    59    234.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    234.6 MiB      0.0 MiB               for j in range(nodes):
    63    234.6 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    234.6 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    234.6 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    234.6 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    234.6 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    234.6 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    234.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    234.6 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 28 time 1566423360.7975078
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.2 MiB    235.2 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.2 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.2 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.2 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.2 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.2 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.2 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.2 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.2 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.8 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.8 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.8 MiB      0.1 MiB           for i in range(nodes):
    59    238.8 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.8 MiB      0.0 MiB               for j in range(nodes):
    63    238.8 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.8 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.8 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.2 MiB      0.1 MiB           for i in range(nodes):
    59    237.2 MiB      0.1 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.2 MiB      0.0 MiB               for j in range(nodes):
    63    237.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.2 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.2 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.2 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.2 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.2 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.2 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 4 time 1566423360.7754538
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.8 MiB    235.8 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.8 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.8 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.8 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.8 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.8 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.8 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.8 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.8 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.4 MiB      0.1 MiB           for i in range(nodes):
    59    237.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.4 MiB      0.0 MiB               for j in range(nodes):
    63    237.4 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.4 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.4 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.7 MiB      0.1 MiB           for i in range(nodes):
    59    239.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.7 MiB      0.0 MiB               for j in range(nodes):
    63    239.7 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.7 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.7 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.7 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.7 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.7 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.7 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 7 time 1566423361.1026065
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.3 MiB    238.3 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.3 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.3 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.3 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.3 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.3 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.3 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.3 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.3 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.9 MiB      0.2 MiB           for i in range(nodes):
    59    239.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.9 MiB      0.2 MiB               for j in range(nodes):
    63    239.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.9 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.9 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.1 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.2 MiB      0.1 MiB           for i in range(nodes):
    59    236.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.2 MiB      0.0 MiB               for j in range(nodes):
    63    236.2 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.2 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.2 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    236.2 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.2 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.2 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 37 time 1566423360.8813372
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    234.9 MiB    234.9 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    234.9 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    234.9 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    234.9 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    234.9 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    234.9 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    234.9 MiB      0.0 MiB           for i in range(max_delay+2):
    50    234.9 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    234.9 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.5 MiB      0.1 MiB           for i in range(nodes):
    59    236.5 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.5 MiB      0.2 MiB               for j in range(nodes):
    63    236.5 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.5 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.5 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.6 MiB    235.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    241.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    241.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    241.7 MiB      0.1 MiB           for i in range(nodes):
    59    241.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    241.7 MiB      0.1 MiB               for j in range(nodes):
    63    241.7 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    241.7 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    241.7 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    241.7 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    241.7 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    241.7 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    241.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    241.8 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 34 time 1566423361.115735
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    240.3 MiB    240.3 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    240.3 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    240.3 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    240.3 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    240.3 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    240.3 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    240.3 MiB      0.0 MiB           for i in range(max_delay+2):
    50    240.3 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    240.3 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    241.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    241.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    241.9 MiB      0.2 MiB           for i in range(nodes):
    59    241.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    241.9 MiB      0.2 MiB               for j in range(nodes):
    63    241.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    241.9 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    241.9 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.5 MiB    231.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.0 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.0 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.0 MiB      0.1 MiB           for i in range(nodes):
    59    238.0 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.0 MiB      0.0 MiB               for j in range(nodes):
    63    238.0 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.0 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.0 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    238.0 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.0 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.0 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.0 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 30 time 1566423361.036464
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.6 MiB    236.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.2 MiB      0.0 MiB           for i in range(nodes):
    59    238.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.2 MiB      0.0 MiB               for j in range(nodes):
    63    238.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.2 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    234.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    234.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    234.4 MiB      0.2 MiB           for i in range(nodes):
    59    234.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    234.4 MiB      0.0 MiB               for j in range(nodes):
    63    234.4 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    234.4 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    234.4 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    234.4 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    234.4 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    234.4 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    234.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.4 MiB      2.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 31 time 1566423361.3125737
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.0 MiB    235.0 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.0 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.0 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.0 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.0 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.0 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.0 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.0 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.0 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.6 MiB      0.1 MiB           for i in range(nodes):
    59    236.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.6 MiB      0.2 MiB               for j in range(nodes):
    63    236.6 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.6 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.6 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.5 MiB      0.1 MiB           for i in range(nodes):
    59    236.5 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.5 MiB      0.0 MiB               for j in range(nodes):
    63    236.5 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.5 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.5 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    236.5 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.5 MiB      0.1 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.5 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.5 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 16 time 1566423361.1600738
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    239.1 MiB    239.1 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    239.1 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    239.1 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    239.1 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    239.1 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    239.1 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    239.1 MiB      0.0 MiB           for i in range(max_delay+2):
    50    239.1 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    239.1 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.7 MiB      0.2 MiB           for i in range(nodes):
    59    240.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.7 MiB      0.0 MiB               for j in range(nodes):
    63    240.7 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.7 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.7 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.6 MiB    229.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.1 MiB      0.1 MiB           for i in range(nodes):
    59    235.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.1 MiB      0.0 MiB               for j in range(nodes):
    63    235.1 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.1 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.1 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.1 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.1 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.1 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.1 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 33 time 1566423361.0491235
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.7 MiB    233.7 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.7 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.7 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.7 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.7 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.7 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.7 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.7 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.7 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.3 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.3 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.3 MiB      0.2 MiB           for i in range(nodes):
    59    235.3 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.3 MiB      0.0 MiB               for j in range(nodes):
    63    235.3 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.3 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.3 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.5 MiB      0.1 MiB           for i in range(nodes):
    59    236.5 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.5 MiB      0.0 MiB               for j in range(nodes):
    63    236.5 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.5 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.5 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    236.5 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.5 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.5 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.5 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 23 time 1566423361.1046534
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    239.1 MiB    239.1 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    239.1 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    239.1 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    239.1 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    239.1 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    239.1 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    239.1 MiB      0.0 MiB           for i in range(max_delay+2):
    50    239.1 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    239.1 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.7 MiB      0.1 MiB           for i in range(nodes):
    59    240.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.7 MiB      0.0 MiB               for j in range(nodes):
    63    240.7 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.7 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.7 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.3 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.3 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.3 MiB      0.1 MiB           for i in range(nodes):
    59    237.3 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.3 MiB      0.1 MiB               for j in range(nodes):
    63    237.3 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.3 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.3 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.3 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.3 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.3 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.3 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.5 MiB      0.2 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 13 time 1566423361.2569783
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.1 MiB    236.1 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.1 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.1 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.1 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.1 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.1 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.1 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.1 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.1 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.6 MiB      0.1 MiB           for i in range(nodes):
    59    237.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.6 MiB      0.0 MiB               for j in range(nodes):
    63    237.6 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.6 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.6 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.6 MiB    233.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.3 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.3 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.3 MiB      0.2 MiB           for i in range(nodes):
    59    239.3 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.3 MiB      0.0 MiB               for j in range(nodes):
    63    239.3 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.3 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.3 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.3 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.3 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.3 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.3 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.3 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 15 time 1566423361.0104675
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    237.9 MiB    237.9 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    237.9 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    237.9 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    237.9 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    237.9 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    237.9 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    237.9 MiB      0.0 MiB           for i in range(max_delay+2):
    50    237.9 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    237.9 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.5 MiB      0.1 MiB           for i in range(nodes):
    59    239.5 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.5 MiB      0.0 MiB               for j in range(nodes):
    63    239.5 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.5 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.5 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.3 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.3 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.3 MiB      0.1 MiB           for i in range(nodes):
    59    240.3 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.3 MiB      0.0 MiB               for j in range(nodes):
    63    240.3 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.3 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.3 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    240.3 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.3 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.3 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.3 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.3 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 3 time 1566423361.1141546
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.9 MiB    238.9 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.9 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.9 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.9 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.9 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.9 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.9 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.9 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.9 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.5 MiB      0.2 MiB           for i in range(nodes):
    59    240.5 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.5 MiB      0.0 MiB               for j in range(nodes):
    63    240.5 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.5 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.5 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.3 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.3 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.3 MiB      0.2 MiB           for i in range(nodes):
    59    237.3 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.3 MiB      0.0 MiB               for j in range(nodes):
    63    237.3 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.3 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.3 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.3 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.3 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.3 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.3 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.4 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 14 time 1566423361.1635273
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.0 MiB    236.0 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.0 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.0 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.0 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.0 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.0 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.0 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.0 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.0 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.6 MiB      0.1 MiB           for i in range(nodes):
    59    237.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.6 MiB      0.0 MiB               for j in range(nodes):
    63    237.6 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.6 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.6 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.5 MiB    231.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.9 MiB      0.1 MiB           for i in range(nodes):
    59    237.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.9 MiB      0.1 MiB               for j in range(nodes):
    63    237.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.9 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.9 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 21 time 1566423361.3132613
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.6 MiB    236.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.1 MiB      0.0 MiB           for i in range(nodes):
    59    238.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.1 MiB      0.0 MiB               for j in range(nodes):
    63    238.1 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.1 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.1 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.1 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.8 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.8 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.8 MiB      0.1 MiB           for i in range(nodes):
    59    235.8 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.8 MiB      0.1 MiB               for j in range(nodes):
    63    235.8 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.8 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.8 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.8 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.8 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.8 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.8 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.8 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 5 time 1566423361.1339655
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    234.4 MiB    234.4 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    234.4 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    234.4 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    234.4 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    234.4 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    234.4 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    234.4 MiB      0.0 MiB           for i in range(max_delay+2):
    50    234.4 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    234.4 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.0 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.0 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.0 MiB      0.2 MiB           for i in range(nodes):
    59    236.0 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.0 MiB      0.0 MiB               for j in range(nodes):
    63    236.0 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.0 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.0 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.0 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.0 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.0 MiB      0.1 MiB           for i in range(nodes):
    59    240.0 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.0 MiB      0.1 MiB               for j in range(nodes):
    63    240.0 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.0 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.0 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    240.0 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.0 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.0 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.0 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 39 time 1566423361.1774745
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.6 MiB    238.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.2 MiB      0.0 MiB           for i in range(nodes):
    59    240.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.2 MiB      0.0 MiB               for j in range(nodes):
    63    240.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.2 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.6 MiB    229.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.2 MiB      0.1 MiB           for i in range(nodes):
    59    236.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.2 MiB      0.0 MiB               for j in range(nodes):
    63    236.2 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.2 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.2 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    236.2 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.2 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 35 time 1566423361.444098
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    234.8 MiB    234.8 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    234.8 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    234.8 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    234.8 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    234.8 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    234.8 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    234.8 MiB      0.0 MiB           for i in range(max_delay+2):
    50    234.8 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    234.8 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.4 MiB      0.1 MiB           for i in range(nodes):
    59    236.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.4 MiB      0.0 MiB               for j in range(nodes):
    63    236.4 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.4 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.4 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.9 MiB      0.1 MiB           for i in range(nodes):
    59    235.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.9 MiB      0.1 MiB               for j in range(nodes):
    63    235.9 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.9 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.9 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.0 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 11 time 1566423361.7207992
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    234.5 MiB    234.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    234.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    234.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    234.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    234.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    234.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    234.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    234.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    234.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    236.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    236.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    236.1 MiB      0.2 MiB           for i in range(nodes):
    59    236.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    236.1 MiB      0.2 MiB               for j in range(nodes):
    63    236.1 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    236.1 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    236.1 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.2 MiB      0.2 MiB           for i in range(nodes):
    59    240.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.2 MiB      0.0 MiB               for j in range(nodes):
    63    240.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.2 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.2 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    240.2 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.2 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.2 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 0 time 1566423361.8167806
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.8 MiB    238.8 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.8 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.8 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.8 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.8 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.8 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.8 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.8 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.8 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.4 MiB      0.2 MiB           for i in range(nodes):
    59    240.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.4 MiB      0.0 MiB               for j in range(nodes):
    63    240.4 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.4 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.4 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.5 MiB    231.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.2 MiB      0.2 MiB           for i in range(nodes):
    59    237.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.2 MiB      0.1 MiB               for j in range(nodes):
    63    237.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.2 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.2 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.2 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.2 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 24 time 1566423361.540006
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.9 MiB    235.9 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.9 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.9 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.9 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.9 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.9 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.9 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.9 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.9 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.5 MiB      0.1 MiB           for i in range(nodes):
    59    237.5 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.5 MiB      0.0 MiB               for j in range(nodes):
    63    237.5 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.5 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.5 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.7 MiB      0.1 MiB           for i in range(nodes):
    59    239.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.7 MiB      0.0 MiB               for j in range(nodes):
    63    239.7 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.7 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.7 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.7 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.7 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.7 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.7 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 9 time 1566423361.4913256
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.3 MiB    238.3 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.3 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.3 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.3 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.3 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.3 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.3 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.3 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.3 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.8 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.8 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.8 MiB      0.2 MiB           for i in range(nodes):
    59    239.8 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.8 MiB      0.0 MiB               for j in range(nodes):
    63    239.8 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.8 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.8 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.0 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.0 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.0 MiB      0.1 MiB           for i in range(nodes):
    59    235.0 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.0 MiB      0.0 MiB               for j in range(nodes):
    63    235.0 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.0 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.0 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.0 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.0 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.0 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.0 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.1 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 36 time 1566423361.45429
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.7 MiB    233.7 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.7 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.7 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.7 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.7 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.7 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.7 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.7 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.7 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.2 MiB      0.1 MiB           for i in range(nodes):
    59    235.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.2 MiB      0.0 MiB               for j in range(nodes):
    63    235.2 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.2 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.6 MiB    229.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    234.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    234.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    234.9 MiB      0.1 MiB           for i in range(nodes):
    59    234.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    234.9 MiB      0.0 MiB               for j in range(nodes):
    63    234.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    234.9 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    234.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    234.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    234.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    234.9 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    234.9 MiB      0.1 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.1 MiB      0.2 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 17 time 1566423361.612908
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.7 MiB    233.7 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.7 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.7 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.7 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.7 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.7 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.7 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.7 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.7 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.2 MiB      0.1 MiB           for i in range(nodes):
    59    235.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.2 MiB      0.0 MiB               for j in range(nodes):
    63    235.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.2 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.6 MiB    233.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.6 MiB      0.2 MiB           for i in range(nodes):
    59    239.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.6 MiB      0.0 MiB               for j in range(nodes):
    63    239.6 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.6 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.6 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.6 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.6 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.6 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.6 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 8 time 1566423361.5908196
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.2 MiB    238.2 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.2 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.2 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.2 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.2 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.2 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.2 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.2 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.2 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.7 MiB      0.2 MiB           for i in range(nodes):
    59    239.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.7 MiB      0.0 MiB               for j in range(nodes):
    63    239.7 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.7 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.7 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.5 MiB    235.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    241.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    241.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    241.9 MiB      0.1 MiB           for i in range(nodes):
    59    241.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    241.9 MiB      0.1 MiB               for j in range(nodes):
    63    241.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    241.9 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    241.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    241.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    241.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    241.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    241.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    242.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 27 time 1566423361.8501585
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    240.6 MiB    240.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    240.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    240.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    240.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    240.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    240.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    240.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    240.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    240.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    242.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    242.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    242.2 MiB      0.1 MiB           for i in range(nodes):
    59    242.2 MiB      0.1 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    242.2 MiB      0.0 MiB               for j in range(nodes):
    63    242.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    242.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    242.2 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.6 MiB    231.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.0 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.0 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.0 MiB      0.1 MiB           for i in range(nodes):
    59    238.0 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.0 MiB      0.2 MiB               for j in range(nodes):
    63    238.0 MiB      0.2 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.0 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.0 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    238.0 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.0 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.0 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.0 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 12 time 1566423362.0255463
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    236.6 MiB    236.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    236.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    236.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    236.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    236.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    236.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    236.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    236.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    236.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    238.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    238.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    238.2 MiB      0.2 MiB           for i in range(nodes):
    59    238.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    238.2 MiB      0.0 MiB               for j in range(nodes):
    63    238.2 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    238.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    238.2 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.5 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.5 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.5 MiB      0.1 MiB           for i in range(nodes):
    59    235.5 MiB      0.2 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.5 MiB      0.1 MiB               for j in range(nodes):
    63    235.5 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.5 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.5 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    235.5 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.5 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.5 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.6 MiB      0.2 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 2 time 1566423363.6098304
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    234.2 MiB    234.2 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    234.2 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    234.2 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    234.2 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    234.2 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    234.2 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    234.2 MiB      0.0 MiB           for i in range(max_delay+2):
    50    234.2 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    234.2 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.8 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.8 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.8 MiB      0.2 MiB           for i in range(nodes):
    59    235.8 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.8 MiB      0.0 MiB               for j in range(nodes):
    63    235.8 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.8 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.8 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    231.5 MiB    231.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    231.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    231.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    231.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    231.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    231.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    231.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    231.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    231.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.1 MiB      0.1 MiB           for i in range(nodes):
    59    237.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.1 MiB      0.0 MiB               for j in range(nodes):
    63    237.1 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.1 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.1 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    237.1 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.1 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.1 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 26 time 1566423363.4701962
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    235.8 MiB    235.8 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    235.8 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    235.8 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    235.8 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    235.8 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    235.8 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    235.8 MiB      0.0 MiB           for i in range(max_delay+2):
    50    235.8 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    235.8 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    237.4 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    237.4 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    237.4 MiB      0.1 MiB           for i in range(nodes):
    59    237.4 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    237.4 MiB      0.0 MiB               for j in range(nodes):
    63    237.4 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    237.4 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    237.4 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    234.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    234.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    234.9 MiB      0.1 MiB           for i in range(nodes):
    59    234.9 MiB      0.1 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    234.9 MiB      0.0 MiB               for j in range(nodes):
    63    234.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    234.9 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    234.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    234.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    234.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    234.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    234.9 MiB      0.3 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    234.9 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 29 time 1566423363.9083586
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.1 MiB      0.1 MiB           for i in range(nodes):
    59    235.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.1 MiB      0.0 MiB               for j in range(nodes):
    63    235.1 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.1 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.1 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.6 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.6 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.6 MiB      0.1 MiB           for i in range(nodes):
    59    239.6 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.6 MiB      0.1 MiB               for j in range(nodes):
    63    239.6 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.6 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.6 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.6 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.6 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.6 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.6 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 25 time 1566423363.7464855
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.2 MiB    238.2 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.2 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.2 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.2 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.2 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.2 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.2 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.2 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.2 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.7 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.7 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.7 MiB      0.1 MiB           for i in range(nodes):
    59    239.7 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.7 MiB      0.1 MiB               for j in range(nodes):
    63    239.7 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.7 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.7 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    229.5 MiB    229.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    229.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    229.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    229.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    229.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    229.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    229.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    229.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    229.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    234.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    234.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    234.9 MiB      0.2 MiB           for i in range(nodes):
    59    234.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    234.9 MiB      0.0 MiB               for j in range(nodes):
    63    234.9 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    234.9 MiB      0.2 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    234.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    234.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    234.9 MiB      0.1 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    234.9 MiB      0.3 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    234.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    234.9 MiB      0.0 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 1 time 1566423363.446954
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.5 MiB    233.5 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.5 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.5 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.5 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.5 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.5 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.5 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.5 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.5 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    235.1 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    235.1 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    235.1 MiB      0.2 MiB           for i in range(nodes):
    59    235.1 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    235.1 MiB      0.0 MiB               for j in range(nodes):
    63    235.1 MiB      0.0 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    235.1 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    235.1 MiB      0.2 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
starting...
generating target data...
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    233.4 MiB    233.4 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    233.4 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    233.4 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    233.4 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    233.4 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    233.4 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    233.4 MiB      0.0 MiB           for i in range(max_delay+2):
    50    233.4 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    233.4 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    239.9 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    239.9 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    239.9 MiB      0.1 MiB           for i in range(nodes):
    59    239.9 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    239.9 MiB      0.0 MiB               for j in range(nodes):
    63    239.9 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    239.9 MiB      0.1 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    239.9 MiB      0.1 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
    73    239.9 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.9 MiB      0.0 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Initialized solver
iter:  1 rank 20 time 1566423363.6214068
calculating initial energies
Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/wc_model_sim_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
    21    238.6 MiB    238.6 MiB   @profile
    22                             def km_model_sim_d(km_params: dict, delays_mat, max_delay, W_mat, nodes, seed_num = 123):
    23                                 """
    24                                 km_params : dictionary containing wi, K, N, timesteps, dt, constant
    25                             
    26                                 """
    27    238.6 MiB      0.0 MiB       w_i, dt, time_steps = km_params['wi'], km_params['dt'], km_params['time_steps']
    28                                 
    29    238.6 MiB      0.0 MiB       N, K = km_params['N'], km_params['K']
    30                                 
    31    238.6 MiB      0.0 MiB       constant = km_params['constant']
    32                                 
    33                             
    34    238.6 MiB      0.0 MiB       theta_tsteps = [] #will be a list of  vectors (lenght = 'max_delay') 
    35                                                 # each of size 'nodes'
    36                             
    37                             
    38    238.6 MiB      0.0 MiB       if not constant:
    39                                     #print("not constant")
    40                                     rng_wc = np.random.RandomState(seed_num)
    41                             
    42                                     for i in range(max_delay+2):
    43                                         ue_0 = rng_wc.randint(low = -25, high = 25, size = nodes)/100
    44                                         
    45                                         theta_tsteps.append(ue_0)
    46                                         
    47                                 else:
    48                                     #print("constant")
    49    238.6 MiB      0.0 MiB           for i in range(max_delay+2):
    50    238.6 MiB      0.0 MiB               ue_0 = np.arange(nodes)*0.0
    51                                 
    52    238.6 MiB      0.0 MiB               theta_tsteps.append(ue_0)
    53                             
    54    240.2 MiB      0.0 MiB       for t in range(max_delay+1, max_delay+1+time_steps):
    55                                     # this is the list that theta value of each node i, at time t
    56    240.2 MiB      0.0 MiB           theta_i_t = []
    57                                     
    58    240.2 MiB      0.2 MiB           for i in range(nodes):
    59    240.2 MiB      0.0 MiB               input_i = 0 # the value of the input into theta at node i
    60                                         
    61                                         # adding up the input from each other node j
    62    240.2 MiB      0.0 MiB               for j in range(nodes):
    63    240.2 MiB      0.1 MiB                   tau_ij = delays_mat[i,j]
    64                             #                print(tau_ij)
    65                                             
    66                                             # the value at row j and column (t-tau_ij)
    67                             #                print(theta_tsteps)
    68    240.2 MiB      0.0 MiB                   theta_j_delay = theta_tsteps[t-tau_ij][j]
    69                                            
    70    240.2 MiB      0.0 MiB                   input_i = input_i + np.sin(theta_j_delay- theta_tsteps[t][i])
    71                                         
    72                                         # the value of theta at node i and time t+1
[mpiexec@nia0018.scinet.local] Sending Ctrl-C to processes as requested
[mpiexec@nia0018.scinet.local] Press Ctrl-C again to force abort
    73    235.4 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.4 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.4 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.5 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    234.0 MiB    234.0 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    234.0 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    234.0 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.2 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.2 MiB      0.0 MiB           r = []
   590    234.2 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.2 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.2 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.2 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.2 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    233.8 MiB    233.8 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    233.8 MiB      0.0 MiB       ind = 0
   483    233.8 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    233.8 MiB      0.0 MiB       for row in range(0,nodes):
   486    233.8 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    233.8 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    233.8 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    233.8 MiB      0.0 MiB               ind += 1
   490    233.8 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    233.8 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    234.0 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    234.0 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    234.0 MiB      0.0 MiB       elif method == "time":
   510    234.2 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.3 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.3 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.3 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.3 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.3 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.3 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.3 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.3 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.3 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    235.1 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.1 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.1 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    233.7 MiB    233.7 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    233.7 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    233.7 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    233.9 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    233.9 MiB      0.0 MiB           r = []
   590    233.9 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    233.9 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    233.9 MiB      0.2 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    233.9 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    233.9 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    233.5 MiB    233.5 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    233.5 MiB      0.0 MiB       ind = 0
   483    233.5 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    233.5 MiB      0.0 MiB       for row in range(0,nodes):
   486    233.5 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    233.5 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    233.5 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    233.5 MiB      0.0 MiB               ind += 1
   490    233.5 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    233.5 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    233.7 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    233.7 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    233.7 MiB      0.0 MiB       elif method == "time":
   510    233.9 MiB      0.2 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    233.9 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.0 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.0 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.0 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.0 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.0 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.0 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.0 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.0 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    237.4 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.4 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.4 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.5 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.0 MiB    236.0 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.0 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.0 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.1 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.1 MiB      0.0 MiB           r = []
   590    236.1 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.1 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.1 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.1 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.1 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    235.8 MiB    235.8 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    235.8 MiB      0.0 MiB       ind = 0
   483    235.8 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    235.8 MiB      0.0 MiB       for row in range(0,nodes):
   486    235.8 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    235.8 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    235.8 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    235.8 MiB      0.0 MiB               ind += 1
   490    235.8 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    235.8 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.0 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.0 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.0 MiB      0.0 MiB       elif method == "time":
   510    236.1 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    236.2 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    237.3 MiB      0.0 MiB           for sing_node in range(nodes):
   515    237.3 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    237.3 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    237.3 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    237.3 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    237.3 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    237.3 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    237.3 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    239.9 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.9 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.5 MiB    238.5 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.5 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.5 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.7 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.7 MiB      0.0 MiB           r = []
   590    238.7 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.7 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.7 MiB      0.2 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.7 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.7 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.3 MiB    238.3 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.3 MiB      0.0 MiB       ind = 0
   483    238.3 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.3 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.3 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.3 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.3 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.3 MiB      0.0 MiB               ind += 1
   490    238.3 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.3 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.5 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.5 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.5 MiB      0.0 MiB       elif method == "time":
   510    238.7 MiB      0.2 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    238.8 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    239.8 MiB      0.0 MiB           for sing_node in range(nodes):
   515    239.8 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    239.8 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    239.8 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    239.8 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    239.8 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    239.8 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    239.8 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    239.7 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.7 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.7 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.9 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.4 MiB    238.4 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.4 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.4 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.4 MiB      0.0 MiB           r = []
   590    238.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.4 MiB      0.0 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.2 MiB    238.2 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.2 MiB      0.0 MiB       ind = 0
   483    238.2 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.2 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.2 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.2 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.2 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.2 MiB      0.0 MiB               ind += 1
   490    238.2 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.2 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.4 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.4 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.4 MiB      0.0 MiB       elif method == "time":
   510    238.4 MiB      0.0 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    238.6 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    239.6 MiB      0.0 MiB           for sing_node in range(nodes):
   515    239.6 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    239.6 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    239.6 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    239.6 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    239.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    239.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    239.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    239.6 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.6 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.6 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.7 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.2 MiB    238.2 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.2 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.2 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.2 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.2 MiB      0.0 MiB           r = []
   590    238.2 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.2 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.2 MiB      0.0 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.2 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.2 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.0 MiB    238.0 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.0 MiB      0.0 MiB       ind = 0
   483    238.0 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.0 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.0 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.0 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.0 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.0 MiB      0.0 MiB               ind += 1
   490    238.0 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.0 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.2 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.2 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.2 MiB      0.0 MiB       elif method == "time":
   510    238.2 MiB      0.0 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    238.4 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    239.4 MiB      0.0 MiB           for sing_node in range(nodes):
   515    239.4 MiB      1.1 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    239.4 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    239.4 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    239.4 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    239.5 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    239.5 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    239.5 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.5 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.5 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.5 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.6 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    239.1 MiB    239.1 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    239.1 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    239.1 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    239.2 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    239.2 MiB      0.0 MiB           r = []
   590    239.2 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    239.2 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    239.2 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    239.2 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    239.2 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.9 MiB    238.9 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.9 MiB      0.0 MiB       ind = 0
   483    238.9 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.9 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.9 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.9 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.9 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.9 MiB      0.0 MiB               ind += 1
   490    238.9 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.9 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    239.1 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    239.1 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    239.1 MiB      0.0 MiB       elif method == "time":
   510    239.2 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.3 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    242.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    242.1 MiB      2.8 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    242.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    242.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    242.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    242.2 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    242.2 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    242.2 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    238.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.8 MiB    236.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.8 MiB      0.0 MiB           r = []
   590    236.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.8 MiB      0.0 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.6 MiB    236.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.6 MiB      0.0 MiB       ind = 0
   483    236.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.6 MiB      0.0 MiB               ind += 1
   490    236.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.8 MiB      0.0 MiB       elif method == "time":
   510    236.8 MiB      0.0 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    237.0 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    238.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    238.1 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    238.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    238.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    238.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    238.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    238.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    238.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.7 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.7 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.7 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.8 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    239.3 MiB    239.3 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    239.3 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    239.3 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    239.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    239.4 MiB      0.0 MiB           r = []
   590    239.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    239.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    239.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    239.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    239.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    239.1 MiB    239.1 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    239.1 MiB      0.0 MiB       ind = 0
   483    239.1 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    239.1 MiB      0.0 MiB       for row in range(0,nodes):
   486    239.1 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    239.1 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    239.1 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    239.1 MiB      0.0 MiB               ind += 1
   490    239.1 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    239.1 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    239.3 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    239.3 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    239.3 MiB      0.0 MiB       elif method == "time":
   510    239.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.5 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    240.5 MiB      0.0 MiB           for sing_node in range(nodes):
   515    240.5 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    240.5 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    240.5 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    240.5 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    240.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    240.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    240.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    235.2 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    233.8 MiB    233.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    233.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    233.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    233.9 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    233.9 MiB      0.0 MiB           r = []
   590    233.9 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    233.9 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    233.9 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    233.9 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    233.9 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    233.6 MiB    233.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    233.6 MiB      0.0 MiB       ind = 0
   483    233.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    233.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    233.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    233.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    233.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    233.6 MiB      0.0 MiB               ind += 1
   490    233.7 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    233.7 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    233.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    233.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    233.8 MiB      0.0 MiB       elif method == "time":
   510    233.9 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.1 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.1 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    238.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.8 MiB    236.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.8 MiB      0.0 MiB           r = []
   590    236.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.8 MiB      0.0 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.6 MiB    236.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.6 MiB      0.0 MiB       ind = 0
   483    236.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.6 MiB      0.0 MiB               ind += 1
   490    236.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.8 MiB      0.0 MiB       elif method == "time":
   510    236.8 MiB      0.0 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    237.0 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    238.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    238.1 MiB      1.1 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    238.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    238.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    238.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    238.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    238.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    238.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.7 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.7 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.7 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.8 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    239.3 MiB    239.3 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    239.3 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    239.3 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    239.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    239.4 MiB      0.0 MiB           r = []
   590    239.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    239.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    239.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    239.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    239.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    237.1 MiB    237.1 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    237.1 MiB      0.0 MiB       ind = 0
   483    237.1 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    237.1 MiB      0.0 MiB       for row in range(0,nodes):
   486    237.1 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    237.1 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    237.1 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    237.1 MiB      0.0 MiB               ind += 1
   490    237.1 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    237.1 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    239.3 MiB      2.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    239.3 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    239.3 MiB      0.0 MiB       elif method == "time":
   510    239.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.6 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    240.6 MiB      0.0 MiB           for sing_node in range(nodes):
   515    240.6 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    240.6 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    240.6 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    240.6 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    240.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    240.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    240.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    235.8 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.8 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.8 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.8 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.9 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    234.7 MiB    234.7 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    234.7 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    234.7 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.8 MiB      0.0 MiB           r = []
   590    234.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.8 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    234.2 MiB    234.2 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    234.2 MiB      0.0 MiB       ind = 0
   483    234.2 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    234.2 MiB      0.0 MiB       for row in range(0,nodes):
   486    234.2 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    234.2 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    234.2 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    234.2 MiB      0.0 MiB               ind += 1
   490    234.2 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    234.2 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    234.7 MiB      0.5 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    234.7 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    234.7 MiB      0.0 MiB       elif method == "time":
   510    234.8 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.9 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.9 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.9 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.9 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.9 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.0 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.0 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.0 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.0 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    239.8 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.8 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.8 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.8 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.9 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.4 MiB    238.4 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.4 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.4 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.5 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.5 MiB      0.0 MiB           r = []
   590    238.5 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.5 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.5 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.5 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.5 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.3 MiB    238.3 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.3 MiB      0.0 MiB       ind = 0
   483    238.3 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.3 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.3 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.3 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.3 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.3 MiB      0.0 MiB               ind += 1
   490    238.3 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.3 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.4 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.4 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.4 MiB      0.0 MiB       elif method == "time":
   510    238.5 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    238.7 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    239.7 MiB      0.0 MiB           for sing_node in range(nodes):
   515    239.7 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    239.7 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    239.7 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    239.7 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    239.7 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    239.7 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    239.7 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    237.6 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.6 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.6 MiB      0.1 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.7 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.2 MiB    236.2 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.2 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.2 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.3 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.3 MiB      0.0 MiB           r = []
   590    236.3 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.3 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.3 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.3 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.3 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.0 MiB    236.0 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.0 MiB      0.0 MiB       ind = 0
   483    236.0 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.0 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.0 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.0 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.0 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.0 MiB      0.0 MiB               ind += 1
   490    236.0 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.0 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.2 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.2 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.2 MiB      0.0 MiB       elif method == "time":
   510    236.3 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    236.4 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    237.4 MiB      0.0 MiB           for sing_node in range(nodes):
   515    237.4 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    237.4 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    237.4 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    237.5 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    237.5 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    237.5 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    237.5 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    239.5 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.5 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.5 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.6 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.1 MiB    238.1 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.1 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.1 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.1 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.1 MiB      0.0 MiB           r = []
   590    238.1 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.1 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.1 MiB      0.0 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.1 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.1 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    237.9 MiB    237.9 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    237.9 MiB      0.0 MiB       ind = 0
   483    237.9 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    237.9 MiB      0.0 MiB       for row in range(0,nodes):
   486    237.9 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    237.9 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    237.9 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    237.9 MiB      0.0 MiB               ind += 1
   490    237.9 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    237.9 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.1 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.1 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.1 MiB      0.0 MiB       elif method == "time":
   510    238.1 MiB      0.0 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    238.3 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    239.4 MiB      0.0 MiB           for sing_node in range(nodes):
   515    239.4 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    239.4 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    239.4 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    239.4 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    239.4 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    239.4 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    239.4 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    238.1 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.1 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.1 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.8 MiB    236.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.8 MiB      0.0 MiB           r = []
   590    236.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.8 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.6 MiB    236.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.6 MiB      0.0 MiB       ind = 0
   483    236.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.6 MiB      0.0 MiB               ind += 1
   490    236.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.8 MiB      0.0 MiB       elif method == "time":
   510    236.8 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    237.0 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    238.0 MiB      0.0 MiB           for sing_node in range(nodes):
   515    238.0 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    238.0 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    238.0 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    238.0 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    238.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    238.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    238.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.1 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.1 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.1 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    235.0 MiB    235.0 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    235.0 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    235.0 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    235.1 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    235.1 MiB      0.0 MiB           r = []
   590    235.1 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    235.1 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    235.1 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    235.1 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    235.1 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    234.5 MiB    234.5 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    234.5 MiB      0.0 MiB       ind = 0
   483    234.5 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    234.5 MiB      0.0 MiB       for row in range(0,nodes):
   486    234.5 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    234.5 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    234.5 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    234.5 MiB      0.0 MiB               ind += 1
   490    234.5 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    234.5 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    235.0 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    235.0 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    235.0 MiB      0.0 MiB       elif method == "time":
   510    235.1 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    235.2 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    236.2 MiB      0.0 MiB           for sing_node in range(nodes):
   515    236.2 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    236.2 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    236.2 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.2 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.2 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.3 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.3 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.2 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    239.0 MiB    239.0 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    239.0 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    239.0 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    239.2 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    239.2 MiB      0.0 MiB           r = []
   590    239.2 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    239.2 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    239.2 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    239.2 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    239.2 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.6 MiB    238.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.6 MiB      0.0 MiB       ind = 0
   483    238.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.6 MiB      0.0 MiB               ind += 1
   490    238.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    239.0 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    239.0 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    239.0 MiB      0.0 MiB       elif method == "time":
   510    239.2 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.3 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    240.3 MiB      0.0 MiB           for sing_node in range(nodes):
   515    240.3 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    240.3 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    240.3 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    240.3 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    240.3 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    240.3 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    240.3 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.6 MiB      0.2 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.6 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.6 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.7 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    235.2 MiB    235.2 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    235.2 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    235.2 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    235.3 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    235.3 MiB      0.0 MiB           r = []
   590    235.3 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    235.3 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    235.3 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    235.3 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    235.3 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    235.0 MiB    235.0 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    235.0 MiB      0.0 MiB       ind = 0
   483    235.0 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    235.0 MiB      0.0 MiB       for row in range(0,nodes):
   486    235.0 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    235.0 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    235.0 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    235.0 MiB      0.0 MiB               ind += 1
   490    235.0 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    235.0 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    235.2 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    235.2 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    235.2 MiB      0.0 MiB       elif method == "time":
   510    235.3 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    235.4 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    236.4 MiB      0.0 MiB           for sing_node in range(nodes):
   515    236.4 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    236.4 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    236.4 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.5 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.5 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.5 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.5 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.7 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.7 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.7 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.8 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    239.3 MiB    239.3 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    239.3 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    239.3 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    239.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    239.4 MiB      0.0 MiB           r = []
   590    239.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    239.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    239.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    239.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    239.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    239.1 MiB    239.1 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    239.1 MiB      0.0 MiB       ind = 0
   483    239.1 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    239.1 MiB      0.0 MiB       for row in range(0,nodes):
   486    239.1 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    239.1 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    239.1 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    239.1 MiB      0.0 MiB               ind += 1
   490    239.1 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    239.1 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    239.3 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    239.3 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    239.3 MiB      0.0 MiB       elif method == "time":
   510    239.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.5 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    240.6 MiB      0.0 MiB           for sing_node in range(nodes):
   515    240.6 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    240.6 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    240.6 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    240.6 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    240.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    240.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    240.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    237.5 MiB      0.2 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.5 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.5 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.6 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.1 MiB    236.1 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.1 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.1 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.2 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.2 MiB      0.0 MiB           r = []
   590    236.2 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.2 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.2 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.2 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.2 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    235.9 MiB    235.9 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    235.9 MiB      0.0 MiB       ind = 0
   483    235.9 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    235.9 MiB      0.0 MiB       for row in range(0,nodes):
   486    235.9 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    235.9 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    235.9 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    235.9 MiB      0.0 MiB               ind += 1
   490    235.9 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    235.9 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.1 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.1 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.1 MiB      0.0 MiB       elif method == "time":
   510    236.2 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    236.3 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    237.3 MiB      0.0 MiB           for sing_node in range(nodes):
   515    237.3 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    237.3 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    237.3 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    237.4 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    237.4 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    237.4 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    237.4 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    239.7 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    239.7 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    239.7 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    239.7 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    239.9 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.6 MiB    238.6 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.6 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.6 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.7 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.7 MiB      0.0 MiB           r = []
   590    238.7 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.7 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.7 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.7 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.7 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.1 MiB    238.1 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.1 MiB      0.0 MiB       ind = 0
   483    238.1 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.1 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.1 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.1 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.1 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.1 MiB      0.0 MiB               ind += 1
   490    238.2 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.2 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.6 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.6 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.6 MiB      0.0 MiB       elif method == "time":
   510    238.7 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    238.8 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    239.9 MiB      0.0 MiB           for sing_node in range(nodes):
   515    239.9 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    239.9 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    239.9 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    239.9 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    239.9 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    239.9 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    239.9 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    237.4 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.4 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.4 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.5 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.3 MiB    236.3 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.3 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.3 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.4 MiB      0.0 MiB           r = []
   590    236.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    235.8 MiB    235.8 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    235.8 MiB      0.0 MiB       ind = 0
   483    235.8 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    235.8 MiB      0.0 MiB       for row in range(0,nodes):
   486    235.8 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    235.8 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    235.8 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    235.8 MiB      0.0 MiB               ind += 1
   490    235.8 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    235.8 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.3 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.3 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.3 MiB      0.0 MiB       elif method == "time":
   510    236.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    236.5 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    237.5 MiB      0.0 MiB           for sing_node in range(nodes):
   515    237.5 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    237.5 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    237.5 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    237.6 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    237.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    237.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    237.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    242.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    242.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    242.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    242.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    242.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    240.8 MiB    240.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    240.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    240.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    240.9 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    240.9 MiB      0.0 MiB           r = []
   590    240.9 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    240.9 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    240.9 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    240.9 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    240.9 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    240.6 MiB    240.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    240.6 MiB      0.0 MiB       ind = 0
   483    240.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    240.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    240.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    240.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    240.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    240.6 MiB      0.0 MiB               ind += 1
   490    240.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    240.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    240.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    240.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    240.8 MiB      0.0 MiB       elif method == "time":
   510    240.9 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    241.0 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    242.0 MiB      0.0 MiB           for sing_node in range(nodes):
   515    242.0 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    242.0 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    242.0 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    242.0 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    242.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    242.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    242.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    238.8 MiB      2.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.8 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.8 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.8 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.9 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    237.4 MiB    237.4 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    237.4 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    237.4 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    237.5 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    237.5 MiB      0.0 MiB           r = []
   590    237.5 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    237.5 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    237.5 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    237.5 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    237.5 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    235.2 MiB    235.2 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    235.2 MiB      0.0 MiB       ind = 0
   483    235.2 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    235.2 MiB      0.0 MiB       for row in range(0,nodes):
   486    235.2 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    235.2 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    235.2 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    235.2 MiB      0.0 MiB               ind += 1
   490    235.2 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    235.2 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    237.4 MiB      2.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    237.4 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    237.4 MiB      0.0 MiB       elif method == "time":
   510    237.5 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    237.6 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    238.6 MiB      0.0 MiB           for sing_node in range(nodes):
   515    238.6 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    238.6 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    238.6 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    238.7 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    238.7 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    238.7 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    238.7 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    238.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.8 MiB    236.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.9 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.9 MiB      0.0 MiB           r = []
   590    236.9 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.9 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.9 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.9 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.9 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.6 MiB    236.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.6 MiB      0.0 MiB       ind = 0
   483    236.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.6 MiB      0.0 MiB               ind += 1
   490    236.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.8 MiB      0.0 MiB       elif method == "time":
   510    236.9 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    237.0 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    238.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    238.1 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    238.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    238.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    238.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    238.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    238.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    238.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.6 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.6 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.6 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.7 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    235.4 MiB    235.4 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    235.4 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    235.4 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    235.6 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    235.6 MiB      0.0 MiB           r = []
   590    235.6 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    235.6 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    235.6 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    235.6 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    235.6 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    235.0 MiB    235.0 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    235.0 MiB      0.0 MiB       ind = 0
   483    235.0 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    235.0 MiB      0.0 MiB       for row in range(0,nodes):
   486    235.0 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    235.0 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    235.0 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    235.0 MiB      0.0 MiB               ind += 1
   490    235.0 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    235.0 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    235.4 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    235.4 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    235.4 MiB      0.0 MiB       elif method == "time":
   510    235.6 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    235.7 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    236.7 MiB      0.0 MiB           for sing_node in range(nodes):
   515    236.7 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    236.7 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    236.7 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.7 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.7 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.7 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.7 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    235.3 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.3 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.3 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.3 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.4 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    233.9 MiB    233.9 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    233.9 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    233.9 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.0 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.0 MiB      0.0 MiB           r = []
   590    234.0 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.0 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.0 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.0 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.0 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    233.7 MiB    233.7 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    233.7 MiB      0.0 MiB       ind = 0
   483    233.7 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    233.7 MiB      0.0 MiB       for row in range(0,nodes):
   486    233.7 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    233.7 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    233.7 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    233.7 MiB      0.0 MiB               ind += 1
   490    233.7 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    233.7 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    233.9 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    233.9 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    233.9 MiB      0.0 MiB       elif method == "time":
   510    234.0 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.1 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.2 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.2 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.2 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.2 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.2 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.2 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.2 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.2 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.4 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.4 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.4 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.5 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    235.0 MiB    235.0 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    235.0 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    235.0 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    235.1 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    235.1 MiB      0.0 MiB           r = []
   590    235.1 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    235.1 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    235.1 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    235.1 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    235.1 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    234.8 MiB    234.8 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    234.8 MiB      0.0 MiB       ind = 0
   483    234.8 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    234.8 MiB      0.0 MiB       for row in range(0,nodes):
   486    234.8 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    234.8 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    234.8 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    234.8 MiB      0.0 MiB               ind += 1
   490    234.8 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    234.8 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    235.0 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    235.0 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    235.0 MiB      0.0 MiB       elif method == "time":
   510    235.1 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    235.2 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    236.3 MiB      0.0 MiB           for sing_node in range(nodes):
   515    236.3 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    236.3 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    236.3 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.3 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.3 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.3 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.3 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.5 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.5 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.5 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.5 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.6 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    235.3 MiB    235.3 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    235.3 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    235.3 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    235.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    235.4 MiB      0.0 MiB           r = []
   590    235.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    235.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    235.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    235.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    235.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    234.9 MiB    234.9 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    234.9 MiB      0.0 MiB       ind = 0
   483    234.9 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    234.9 MiB      0.0 MiB       for row in range(0,nodes):
   486    234.9 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    234.9 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    234.9 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    234.9 MiB      0.0 MiB               ind += 1
   490    234.9 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    234.9 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    235.3 MiB      0.5 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    235.3 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    235.3 MiB      0.0 MiB       elif method == "time":
   510    235.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    235.6 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    236.6 MiB      0.0 MiB           for sing_node in range(nodes):
   515    236.6 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    236.6 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    236.6 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.6 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.4 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.4 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.4 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.4 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.5 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    239.3 MiB    239.3 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    239.3 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    239.3 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    239.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    239.4 MiB      0.0 MiB           r = []
   590    239.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    239.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    239.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    239.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    239.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.8 MiB    238.8 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.8 MiB      0.0 MiB       ind = 0
   483    238.8 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.8 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.8 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.8 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.8 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.8 MiB      0.0 MiB               ind += 1
   490    238.8 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.8 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    239.3 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    239.3 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    239.3 MiB      0.0 MiB       elif method == "time":
   510    239.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.5 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    240.5 MiB      0.0 MiB           for sing_node in range(nodes):
   515    240.5 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    240.5 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    240.5 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    240.6 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    240.6 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    240.6 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    240.6 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    237.6 MiB      0.1 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    237.6 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    237.6 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    237.6 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    237.7 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.2 MiB    236.2 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.2 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.2 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.4 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.4 MiB      0.0 MiB           r = []
   590    236.4 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.4 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.4 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.4 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.4 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.0 MiB    236.0 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.0 MiB      0.0 MiB       ind = 0
   483    236.0 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.0 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.0 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.0 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.0 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.0 MiB      0.0 MiB               ind += 1
   490    236.0 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.0 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.2 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.2 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.2 MiB      0.0 MiB       elif method == "time":
   510    236.4 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    236.5 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    237.5 MiB      0.0 MiB           for sing_node in range(nodes):
   515    237.5 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    237.5 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    237.5 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    237.5 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    237.5 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    237.5 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    237.5 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    238.1 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    238.1 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    238.1 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    238.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    238.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    236.7 MiB    236.7 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    236.7 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    236.7 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    236.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    236.8 MiB      0.0 MiB           r = []
   590    236.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    236.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    236.8 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    236.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    236.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    236.5 MiB    236.5 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    236.5 MiB      0.0 MiB       ind = 0
   483    236.5 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    236.5 MiB      0.0 MiB       for row in range(0,nodes):
   486    236.5 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    236.5 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    236.5 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    236.5 MiB      0.0 MiB               ind += 1
   490    236.5 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    236.5 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    236.7 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    236.7 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    236.7 MiB      0.0 MiB       elif method == "time":
   510    236.8 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    236.9 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    237.9 MiB      0.0 MiB           for sing_node in range(nodes):
   515    237.9 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    237.9 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    237.9 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    238.0 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    238.0 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    238.0 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    238.0 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    241.9 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    241.9 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    241.9 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    241.9 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    242.0 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    240.5 MiB    240.5 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    240.5 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    240.5 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    240.6 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    240.6 MiB      0.0 MiB           r = []
   590    240.6 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    240.6 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    240.6 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    240.6 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    240.6 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    240.3 MiB    240.3 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    240.3 MiB      0.0 MiB       ind = 0
   483    240.3 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    240.3 MiB      0.0 MiB       for row in range(0,nodes):
   486    240.3 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    240.3 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    240.3 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    240.3 MiB      0.0 MiB               ind += 1
   490    240.3 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    240.3 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    240.5 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    240.5 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    240.5 MiB      0.0 MiB       elif method == "time":
   510    240.6 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    240.8 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    241.8 MiB      0.0 MiB           for sing_node in range(nodes):
   515    241.8 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    241.8 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    241.8 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    241.8 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    241.8 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    241.8 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    241.8 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    235.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.2 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    233.8 MiB    233.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    233.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    233.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.0 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.0 MiB      0.0 MiB           r = []
   590    234.0 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.0 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.0 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.0 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.0 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    233.6 MiB    233.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    233.6 MiB      0.0 MiB       ind = 0
   483    233.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    233.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    233.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    233.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    233.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    233.6 MiB      0.0 MiB               ind += 1
   490    233.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    233.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    233.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    233.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    233.8 MiB      0.0 MiB       elif method == "time":
   510    234.0 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.1 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.1 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.1 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.1 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.1 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    234.7 MiB    234.7 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    234.7 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    234.7 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.8 MiB      0.0 MiB           r = []
   590    234.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.8 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    234.5 MiB    234.5 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    234.5 MiB      0.0 MiB       ind = 0
   483    234.5 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    234.5 MiB      0.0 MiB       for row in range(0,nodes):
   486    234.5 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    234.5 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    234.5 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    234.5 MiB      0.0 MiB               ind += 1
   490    234.5 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    234.5 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    234.7 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    234.7 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    234.7 MiB      0.0 MiB       elif method == "time":
   510    234.8 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.9 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.9 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.9 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.9 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.9 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    236.0 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    236.0 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    236.0 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    236.0 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    240.2 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    240.2 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    240.2 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    240.2 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    240.3 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    238.8 MiB    238.8 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    238.8 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    238.8 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    238.9 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    238.9 MiB      0.0 MiB           r = []
   590    238.9 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    238.9 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    238.9 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    238.9 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    238.9 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    238.6 MiB    238.6 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    238.6 MiB      0.0 MiB       ind = 0
   483    238.6 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    238.6 MiB      0.0 MiB       for row in range(0,nodes):
   486    238.6 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    238.6 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    238.6 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    238.6 MiB      0.0 MiB               ind += 1
   490    238.6 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    238.6 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    238.8 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    238.8 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    238.8 MiB      0.0 MiB       elif method == "time":
   510    238.9 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    239.0 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    240.1 MiB      0.0 MiB           for sing_node in range(nodes):
   515    240.1 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    240.1 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    240.1 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    240.1 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    240.1 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    240.1 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    240.1 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    235.1 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    235.1 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    235.1 MiB      0.2 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    235.1 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    235.2 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    234.0 MiB    234.0 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    234.0 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    234.0 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.0 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.0 MiB      0.0 MiB           r = []
   590    234.0 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.0 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.0 MiB      0.0 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.0 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.0 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    233.5 MiB    233.5 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    233.5 MiB      0.0 MiB       ind = 0
   483    233.5 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    233.5 MiB      0.0 MiB       for row in range(0,nodes):
   486    233.5 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    233.5 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    233.5 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    233.5 MiB      0.0 MiB               ind += 1
   490    233.5 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    233.5 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    234.0 MiB      0.4 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    234.0 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    234.0 MiB      0.0 MiB       elif method == "time":
   510    234.0 MiB      0.0 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.2 MiB      0.2 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.2 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.2 MiB      1.1 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.2 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.2 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.2 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.2 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.3 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.3 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km


    73    236.0 MiB      0.0 MiB               theta_i = (w_i[i] + (K/N)* input_i)*dt + theta_tsteps[t][i]
    74    236.0 MiB      0.2 MiB               theta_i_mod = np.mod(theta_i, 2*np.pi)
    75                                         # append it to the full list of theta's at time t+ 1
    76    236.0 MiB      0.0 MiB               theta_i_t.append(theta_i_mod)
    77                                     
    78                                     #print(np.shape(theta_i_t), "shape of theta_i_t")
    79    236.0 MiB      0.0 MiB           theta_tsteps.append(theta_i_t)
    80                                     #print(np.shape(theta_tsteps))
    81    236.1 MiB      0.1 MiB       return np.transpose(np.array(theta_tsteps))


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   573    234.6 MiB    234.6 MiB   @profile
   574                             def order_param_time(data_1, data_2,skip):
   575                                 """
   576                                 calculates the order param between two KM oscillators and returns the 
   577                                 vector with elements for each time point
   578                                 # np.absolute takes the modulus of real+imaginary number
   579                             
   580                                 # sometimes even if you input the same array for data1 and data2, the r
   581                                 will not be 1 because of precision/rounding error
   582                                 """
   583    234.6 MiB      0.0 MiB       if data_1.shape != data_2.shape:
   584                                     return False
   585                                 
   586    234.6 MiB      0.0 MiB       matrix_r = []
   587                                 
   588    234.8 MiB      0.0 MiB       for node in range(data_1.shape[0]):
   589    234.8 MiB      0.0 MiB           r = []
   590    234.8 MiB      0.0 MiB           for i in range(np.size(data_1[node])):
   591    234.8 MiB      0.0 MiB               r.append(np.absolute(np.exp(1j*data_1[node][i])+
   592    234.8 MiB      0.1 MiB                                                np.exp(1j*data_2[node][i]))/2)
   593    234.8 MiB      0.0 MiB           matrix_r.append(r)
   594                                 
   595    234.8 MiB      0.0 MiB       return np.array(matrix_r)


Filename: /gpfs/fs0/scratch/l/lfefebvr/noorir/model/helper_functions.py

Line #    Mem usage    Increment   Line Contents
================================================
   468    234.4 MiB    234.4 MiB   @profile
   469                             def residuals_km(d, params, nodes, targ_data, w_mat, upper, method = "r_avg"):          
   470                                                    
   471                                 """
   472                                 This function is used to optimize the network model based on kurumoto
   473                                 model's order parameter
   474                                 
   475                                 d: vector that you are trying to optimize - i.e. delay matrix converted
   476                                 to a vector
   477                                 
   478                                 params: dict containing the wc and simulation params for the population
   479                                 models at each node; contains 
   480                                 """
   481                                 
   482    234.4 MiB      0.0 MiB       ind = 0
   483    234.4 MiB      0.0 MiB       dmat = np.ones((nodes, nodes))
   484                                 
   485    234.4 MiB      0.0 MiB       for row in range(0,nodes):
   486    234.4 MiB      0.0 MiB           for col in range(row+1, nodes):
   487    234.4 MiB      0.0 MiB               dmat[row,col] = d[ind]
   488    234.4 MiB      0.0 MiB               dmat[col,row] = d[ind]
   489    234.4 MiB      0.0 MiB               ind += 1
   490    234.4 MiB      0.0 MiB       np.fill_diagonal(dmat,0)
   491    234.4 MiB      0.0 MiB       dmat = dmat.astype(int)
   492                             
   493    234.6 MiB      0.2 MiB       ue_array = wcm.km_model_sim_d(params, dmat, upper, w_mat, nodes)
   494                                 
   495                                
   496                                 #order param
   497                                
   498    234.6 MiB      0.0 MiB       if method == "r_avg":
   499                                     exp_data = order_param_matrix(ue_array, nodes, skip= upper+10)
   500                                     
   501                                     exp_data_p = matrix2p(exp_data)
   502                                     targ_data_p = matrix2p(targ_data)
   503                                     
   504                                     #quantity we are trying to minimize is the mse 
   505                                     res_km = mse(targ_data_p,exp_data_p)
   506                                     
   507                                     return res_km
   508                                 
   509    234.6 MiB      0.0 MiB       elif method == "time":
   510    234.8 MiB      0.1 MiB           order_params = order_param_time(ue_array, targ_data, skip= upper+10)
   511    234.8 MiB      0.1 MiB           res_km = mse(order_params, np.ones_like(order_params))
   512                                     
   513                                     #tempp
   514    235.8 MiB      0.0 MiB           for sing_node in range(nodes):
   515    235.8 MiB      1.0 MiB               plt.plot(ue_array[sing_node], '-k', linewidth=0.2)
   516    235.8 MiB      0.0 MiB           plt.xlabel("Time (ms)", fontsize = "xx-large")
   517    235.8 MiB      0.0 MiB           plt.ylabel("$theta$", fontsize = "xx-large")
   518    235.9 MiB      0.0 MiB           plt.xticks(fontsize = 20)
   519    235.9 MiB      0.0 MiB           plt.yticks(fontsize = 20)
   520    235.9 MiB      0.0 MiB           plt.show()
   521                             
   522                                     
   523    235.9 MiB      0.0 MiB           return res_km
   524                                 elif method == "mse":
   525                                     res_km = mse(targ_data,ue_array)
   526                                     return res_km



===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 0 PID 450150 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 1 PID 450151 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 2 PID 450152 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 3 PID 450153 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 4 PID 450154 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 5 PID 450155 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 6 PID 450156 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 7 PID 450157 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 8 PID 450158 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 9 PID 450159 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 10 PID 450160 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 11 PID 450161 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 12 PID 450162 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 13 PID 450163 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 14 PID 450164 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 15 PID 450165 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 16 PID 450166 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 17 PID 450167 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 18 PID 450168 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 19 PID 450169 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 20 PID 450170 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 21 PID 450171 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 22 PID 450172 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 23 PID 450173 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 24 PID 450174 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 25 PID 450175 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 26 PID 450176 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 27 PID 450177 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 28 PID 450178 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 29 PID 450179 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 30 PID 450180 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 31 PID 450181 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 32 PID 450182 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 33 PID 450183 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 34 PID 450184 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 35 PID 450185 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 36 PID 450186 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 37 PID 450187 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 38 PID 450188 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================

===================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   RANK 39 PID 450189 RUNNING AT nia0018
=   EXIT STATUS: 1
===================================================================================
